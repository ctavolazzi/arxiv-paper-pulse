# Image Generation Module Architecture Plan

## Status: In Progress
**Started:** 2025-11-01 21:15
**Last Updated:** 2025-11-01 21:15

## Objective
Design a properly configured, modular architecture for integrating image generation into the loot-based game system. The image generation module should be a standalone, reusable component with clear input/output contracts and proper integration patterns.

## Architecture Overview

```
┌─────────────────────────────────────────────────────────────────┐
│                         Application Layer                        │
│  (API Endpoints, CLI Commands, Game Actions)                     │
└────────────────────┬────────────────────────────────────────────┘
                     │
                     │ Uses
                     ▼
┌─────────────────────────────────────────────────────────────────┐
│                      Orchestration Layer                         │
│  (LootConverter, GameEngine - coordinate multiple modules)      │
└─────────────┬───────────────────────┬───────────────────────────┘
              │                       │
              │ Depends on            │ Depends on
              ▼                       ▼
┌─────────────────────────┐  ┌──────────────────────────────────┐
│   ImageGenerator        │  │     ArxivSummarizer              │
│   (Core Module)        │  │     (Existing)                    │
│                        │  │                                   │
│  INPUT:                │  │  OUTPUT:                          │
│  - prompt: str         │  │  - paper data: dict               │
│  - base_image: Image   │  │                                   │
│                        │  │                                   │
│  OUTPUT:               │  │                                   │
│  - PIL.Image           │  │                                   │
│  - image_path: str     │  │                                   │
└─────────────────────────┘  └──────────────────────────────────┘
              │                       │
              │                       │
              ▼                       ▼
        ┌─────────────────────────────────────┐
        │         Config Module               │
        │  (Centralized configuration)        │
        └─────────────────────────────────────┘
```

## Module Design Principles

### 1. Single Responsibility
Each module has one clear purpose:
- **ImageGenerator**: Generate/edit images using Gemini API
- **LootConverter**: Transform papers into game items
- **GameEngine**: Manage game state and mechanics
- **Config**: Centralized configuration management

### 2. Dependency Injection
Modules accept dependencies through constructor parameters:
- Avoid global state where possible
- Make dependencies explicit
- Enable testing with mocks

### 3. Clear Input/Output Contracts
- Input types are well-defined (Pydantic models where appropriate)
- Output types are consistent and documented
- Error handling is explicit

### 4. Configuration Management
- All configuration in `config.py`
- Environment variables for secrets
- Feature flags for optional behavior

## ImageGenerator Module Interface

### Input Contracts

#### Method: `generate_from_text(prompt: str) -> Image.Image`
**Input:**
- `prompt: str` - Text description of image to generate
- No external dependencies required

**Output:**
- `PIL.Image` - Generated image object
- Raises `ValueError` if no image data in response

#### Method: `generate_from_text_and_image(prompt: str, base_image: Image.Image) -> Image.Image`
**Input:**
- `prompt: str` - Edit instructions
- `base_image: PIL.Image` - Base image to edit

**Output:**
- `PIL.Image` - Edited image object
- Raises `ValueError` if no image data in response

#### Method: `generate_and_save(prompt: str, output_path: str) -> str`
**Input:**
- `prompt: str` - Text description
- `output_path: str` - File path where image should be saved

**Output:**
- `str` - Path to saved file
- Creates directory structure if needed

### Configuration

#### Current Implementation
```python
class ImageGenerator:
    def __init__(self, api_key=None):
        self.api_key = api_key or config.GEMINI_API_KEY
        self.model = "gemini-2.5-flash-image-preview"
        self.client = genai.Client(api_key=self.api_key)
```

#### Proposed Enhancement
```python
# In config.py
IMAGE_MODEL = os.getenv("IMAGE_MODEL", "gemini-2.5-flash-image-preview")
IMAGE_OUTPUT_DIR = "arxiv_paper_pulse/data/images"
IMAGE_CACHE_ENABLED = os.getenv("IMAGE_CACHE_ENABLED", "true").lower() == "true"
IMAGE_CACHE_TTL = int(os.getenv("IMAGE_CACHE_TTL", "86400"))  # 24 hours

# In image_generator.py
class ImageGenerator:
    def __init__(self, api_key=None, model=None, output_dir=None):
        self.api_key = api_key or config.GEMINI_API_KEY
        self.model = model or config.IMAGE_MODEL
        self.output_dir = Path(output_dir or config.IMAGE_OUTPUT_DIR)
        self.output_dir.mkdir(parents=True, exist_ok=True)
        self.client = genai.Client(api_key=self.api_key)
```

## Integration Patterns

### Pattern 1: Direct Usage (Simple Cases)
**Use Case:** Generate image from user prompt

```python
# In API endpoint
generator = ImageGenerator()
image = generator.generate_from_text(prompt)
path = generator.save_image(image, "output.png")
```

### Pattern 2: Dependency Injection (Complex Modules)
**Use Case:** LootConverter needs image generation

```python
# In loot_converter.py
class LootConverter:
    def __init__(self, image_generator: ImageGenerator):
        self.image_generator = image_generator

    def create_loot_card(self, paper: dict) -> dict:
        prompt = self._create_card_prompt(paper)
        image = self.image_generator.generate_from_text(prompt)
        return {
            "paper_id": paper["id"],
            "image_path": self._save_card_image(image, paper["id"]),
            "rarity": self._calculate_rarity(paper)
        }
```

### Pattern 3: Module Composition (Game Engine)
**Use Case:** GameEngine orchestrates multiple modules

```python
# In game_engine.py
class GameEngine:
    def __init__(self, image_generator: ImageGenerator, loot_converter: LootConverter):
        self.image_generator = image_generator
        self.loot_converter = loot_converter
        self.inventory = []

    def process_paper(self, paper: dict) -> dict:
        loot_item = self.loot_converter.create_loot_card(paper)
        self.inventory.append(loot_item)
        return loot_item
```

### Pattern 4: Factory Pattern (Configuration)
**Use Case:** Create configured instances

```python
# In api.py or game_factory.py
def create_image_generator() -> ImageGenerator:
    """Factory function for creating configured ImageGenerator"""
    return ImageGenerator(
        api_key=config.GEMINI_API_KEY,
        model=config.IMAGE_MODEL,
        output_dir=config.IMAGE_OUTPUT_DIR
    )

def create_loot_converter() -> LootConverter:
    """Factory function for creating configured LootConverter"""
    return LootConverter(
        image_generator=create_image_generator()
    )

def create_game_engine() -> GameEngine:
    """Factory function for creating configured GameEngine"""
    return GameEngine(
        image_generator=create_image_generator(),
        loot_converter=create_loot_converter()
    )
```

## Data Flow

### Flow 1: Simple Image Generation
```
User Input (prompt: str)
    ↓
API Endpoint
    ↓
ImageGenerator.generate_from_text()
    ↓
Gemini API
    ↓
PIL.Image
    ↓
ImageGenerator.save_image()
    ↓
File System (image_path: str)
    ↓
API Response {status, image_path}
```

### Flow 2: Paper → Loot Card
```
ArXiv Paper (dict)
    ↓
LootConverter.create_loot_card()
    ├─ Extract paper properties
    ├─ Calculate rarity
    ├─ Generate card prompt
    ↓
ImageGenerator.generate_from_text(prompt)
    ↓
PIL.Image
    ↓
Save card image
    ↓
LootItem {
    paper_id: str,
    image_path: str,
    rarity: str,
    stats: dict
}
```

### Flow 3: Game Action → Visual Update
```
Game Action (e.g., "open loot box")
    ↓
GameEngine.process_action()
    ├─ Select papers from queue
    ├─ For each paper:
    │   ├─ LootConverter.create_loot_card()
    │   │   └─ ImageGenerator.generate_from_text()
    │   └─ Add to inventory
    ↓
Game State Update
    ↓
Frontend Display (show loot cards)
```

## State Management

### Image Caching Strategy

#### Option 1: File-Based Cache (Simple)
```python
# In ImageGenerator
def _get_cache_path(self, prompt: str) -> Path:
    import hashlib
    cache_key = hashlib.md5(prompt.encode()).hexdigest()
    return self.output_dir / f"cache_{cache_key}.png"

def generate_from_text(self, prompt: str, use_cache=True) -> Image.Image:
    if use_cache and config.IMAGE_CACHE_ENABLED:
        cache_path = self._get_cache_path(prompt)
        if cache_path.exists():
            return Image.open(cache_path)

    # Generate new image
    image = self._generate(prompt)

    if use_cache:
        self.save_image(image, str(cache_path))

    return image
```

#### Option 2: In-Memory Cache (Performance)
```python
# In ImageGenerator
from functools import lru_cache

@lru_cache(maxsize=100)
def _generate_cached(self, prompt_hash: str) -> bytes:
    # Generate and return image bytes
    pass
```

### Configuration State

All state in `config.py`:
- No module-level state
- Configuration read at initialization
- Environment variables override defaults

## Error Handling

### ImageGenerator Errors

```python
class ImageGenerationError(Exception):
    """Base exception for image generation errors"""
    pass

class NoImageDataError(ImageGenerationError):
    """Raised when API response contains no image data"""
    pass

class APIError(ImageGenerationError):
    """Raised when Gemini API returns an error"""
    pass

# In ImageGenerator methods
def generate_from_text(self, prompt: str) -> Image.Image:
    try:
        response = self.client.models.generate_content(...)
        # ... extract image
    except Exception as e:
        if "rate limit" in str(e).lower():
            raise APIError(f"Rate limit exceeded: {e}")
        raise NoImageDataError(f"No image data in response: {e}")
```

## Testing Strategy

### Unit Tests (ImageGenerator)
- Mock Gemini API client
- Test prompt validation
- Test error handling
- Test image saving

### Integration Tests (Module Composition)
- Test ImageGenerator + LootConverter
- Test GameEngine with all modules
- Test configuration loading

### Contract Tests (Input/Output)
- Verify input types accepted
- Verify output types returned
- Verify error types raised

## Configuration Management Plan

### Step 1: Add Image Config to config.py
```python
# Image generation configuration
IMAGE_MODEL = os.getenv("IMAGE_MODEL", "gemini-2.5-flash-image-preview")
IMAGE_OUTPUT_DIR = Path("arxiv_paper_pulse/data/images")
IMAGE_CACHE_ENABLED = os.getenv("IMAGE_CACHE_ENABLED", "true").lower() == "true"
IMAGE_CACHE_TTL = int(os.getenv("IMAGE_CACHE_TTL", "86400"))  # 24 hours
```

### Step 2: Update ImageGenerator to Use Config
- Remove hardcoded values
- Use config.IMAGE_MODEL, config.IMAGE_OUTPUT_DIR
- Add cache support if configured

### Step 3: Add Configuration to .env Template
```bash
# Image Generation
IMAGE_MODEL=gemini-2.5-flash-image-preview
IMAGE_CACHE_ENABLED=true
IMAGE_CACHE_TTL=86400
```

## Next Steps

1. ✅ **Review current ImageGenerator implementation**
2. ⏳ **Enhance ImageGenerator with configuration support**
3. ⏳ **Create Pydantic models for image generation inputs/outputs**
4. ⏳ **Implement caching strategy**
5. ⏳ **Create factory functions for module instantiation**
6. ⏳ **Add error handling classes**
7. ⏳ **Update API endpoint to use configured instance**
8. ⏳ **Write unit tests for ImageGenerator**
9. ⏳ **Document module interface and usage**

## Notes

- Following direct & minimal Python style guide
- No unnecessary abstractions
- Configuration centralized in config.py
- Clear module boundaries and responsibilities
- Easy to test and mock


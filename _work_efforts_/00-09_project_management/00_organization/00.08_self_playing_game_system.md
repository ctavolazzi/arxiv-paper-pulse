# Work Effort: Self-Playing, Self-Designing Game System

## Status: Phase 1 Complete
**Started:** 2025-11-01 21:09
**Last Updated:** 2025-11-01 21:45

## Objective
Create a meta-game system that designs itself, plays itself, tests itself, verifies/debugs itself, and produces a polished, well-tested, well-documented game loop at the end. Use existing arxiv-paper-pulse building blocks cleverly and keep it simple.

## Vision
A game that:
1. **Self-Designs**: Uses Gemini API to generate game mechanics, rules, and Python code
2. **Self-Plays**: Executes the generated game code and runs game loops autonomously
3. **Self-Tests**: Generates and runs test cases to validate game behavior
4. **Self-Verifies/Debugs**: Detects issues in generated code and fixes them iteratively
5. **Polished Output**: Produces final game with documentation and test coverage

## Architecture: Using Existing Building Blocks

### Component Reuse Strategy

#### 1. **Self-Designing** (Code Generation)
- **Use:** `ArxivSummarizer.gemini_summarize()` with structured output
- **Approach:** Prompt Gemini to generate Python game code
- **Output:** Python code string that defines game class/loop
- **Storage:** Save to temporary `.py` files for execution

#### 2. **Self-Playing** (Code Execution)
- **Use:** Python `exec()` or `importlib` to execute generated code
- **Approach:** Import and instantiate generated game class, run game loop
- **Execution:** Sandboxed execution environment with timeout
- **Capture:** Game state, actions, outputs for verification

#### 3. **Self-Testing** (Test Generation)
- **Use:** `gemini_summarize()` with structured output (Pydantic test schemas)
- **Approach:** Generate test cases from game code analysis
- **Execution:** Use `pytest` or custom test runner
- **Validation:** Check test coverage and pass rates

#### 4. **Self-Verifying/Debugging** (Code Analysis & Fix)
- **Use:** `PaperChatSession` from `chat.py` for iterative refinement
- **Approach:** Multi-turn conversation to analyze errors and fix code
- **Process:**
  1. Run generated code → capture errors
  2. Feed errors to Gemini with code context
  3. Get fixed code → retry execution
  4. Repeat until working or max iterations

#### 5. **Documentation & Polish** (Final Output)
- **Use:** `gemini_summarize()` with structured output
- **Approach:** Generate README, docstrings, and usage examples
- **Image Generation:** Use `ImageGenerator` to create game visuals if needed
- **Output:** Complete game package with docs and tests

## Simple Implementation Plan

### Phase 1: Core Engine (Simple Start)
**Goal:** Basic self-designing and self-playing loop

**Components:**
- `SelfDesigningGame` class
- Uses Gemini API to generate simple game code
- Executes generated code safely
- Basic error handling

**Simple Game Type:** Start with text-based games (e.g., guessing games, simple RPGs, turn-based strategy)

**Flow:**
1. Generate game code from prompt → Python string
2. Save to temp file → `game_temp.py`
3. Import and execute → `import game_temp; game = Game(); game.play()`
4. Capture output/errors → logs

### Phase 2: Self-Testing
**Goal:** Generate and run tests automatically

**Components:**
- Test generation using structured output
- Test execution using pytest subprocess
- Coverage reporting

**Flow:**
1. Analyze generated game code
2. Generate test cases (structured Pydantic schema)
3. Create `test_game.py` file
4. Run `pytest test_game.py`
5. Capture results

### Phase 3: Self-Debugging
**Goal:** Iterative refinement loop

**Components:**
- Error capture and analysis
- Chat session for code fixes
- Retry logic with max iterations

**Flow:**
1. Run game → error occurs
2. Feed error + code to Gemini chat
3. Get fixed code version
4. Retry execution
5. Repeat until success or limit

### Phase 4: Polish & Documentation
**Goal:** Final polished output

**Components:**
- Documentation generation
- Code cleanup suggestions
- Final validation

**Flow:**
1. Generate README from game code
2. Generate docstrings
3. Generate usage examples
4. Final test run
5. Output complete package

## Technical Implementation

### Core Module: `self_playing_game.py`

```python
class SelfDesigningGame:
    def __init__(self, api_key=None):
        # Use existing Gemini client setup
        from .core import ArxivSummarizer
        self.summarizer = ArxivSummarizer(api_key=api_key)

    def design_game(self, prompt: str) -> str:
        # Use Gemini to generate game code
        game_code_prompt = f"""Generate a simple Python game. Requirements:
{prompt}

Return ONLY valid Python code that defines:
- A Game class with __init__() and play() methods
- Game logic inside play() method
- Use print() for output, input() for user input
- Keep it simple and working"""

        code = self.summarizer.gemini_summarize(game_code_prompt)
        return code

    def execute_game(self, code: str) -> dict:
        # Execute generated code safely
        # Return execution results
        pass

    def generate_tests(self, code: str) -> str:
        # Generate test code
        pass

    def verify_and_fix(self, code: str, errors: list) -> str:
        # Use chat session to fix issues
        pass
```

### Simple Game Requirements (Start Simple)
- **Text-based** (no graphics needed initially)
- **Short gameplay loops** (< 10 turns/rounds)
- **Deterministic** (easier to test)
- **No external dependencies** (pure Python stdlib)

### Execution Safety
- Timeout limits (max 30 seconds execution)
- Memory limits
- Restricted imports (no file system, no network)
- Sandboxed environment

### Output Structure
```
self_generated_games/
  game_001_<timestamp>/
    game.py           # Generated game code
    test_game.py      # Generated tests
    README.md         # Generated documentation
    run_results.json  # Execution results
```

## Tasks

### Phase 1: Core Engine (Simple Start) ✅ COMPLETE
- [x] Create `arxiv_paper_pulse/self_playing_game.py` module
- [x] Implement `SelfDesigningGame` class with direct Gemini client (following ImageGenerator pattern)
- [x] Add `extract_python_code()` method for markdown code block extraction
- [x] Add `validate_game_structure()` method using AST parsing
- [x] Add `design_game()` method using Gemini API with game generation prompt
- [x] Add `execute_game()` method with subprocess isolation and timeout
- [x] Add `save_game()` method for saving code and execution results
- [x] Create basic error handling with structured return values
- [x] Add `GAME_OUTPUT_DIR` configuration
- [x] Create output directory with README
- [x] Add API endpoint `/api/generate-self-playing-game`
- [x] Create comprehensive test suite

### Phase 2: Self-Testing
- [ ] Add `generate_tests()` method
- [ ] Create Pydantic schema for test cases
- [ ] Implement test execution using pytest
- [ ] Add test coverage reporting
- [ ] Test with generated games

### Phase 3: Self-Debugging
- [ ] Add `verify_and_fix()` method
- [ ] Integrate `PaperChatSession` for iterative fixes
- [ ] Add retry logic with max iterations (3-5)
- [ ] Capture and analyze error types
- [ ] Test error recovery

### Phase 4: Polish & Documentation
- [ ] Add `generate_documentation()` method
- [ ] Create README generation
- [ ] Add docstring generation
- [ ] Generate usage examples
- [ ] Final output packaging

### Phase 5: Integration
- [ ] Add API endpoint `/api/generate-self-playing-game`
- [ ] Add CLI command `self-game --prompt "..."'
- [ ] Create frontend interface (optional)

## Simple Examples (Start Here)

### Example 1: Number Guessing Game
**Prompt:** "Create a number guessing game where the computer picks a number 1-100 and player guesses"

**Expected Output:**
- Game class with play() method
- Random number generation
- Input validation
- Win/lose conditions
- Tests covering all paths

### Example 2: Simple Text Adventure
**Prompt:** "Create a simple text adventure with 3 rooms and player movement"

**Expected Output:**
- Game class with rooms/state
- Navigation logic
- Simple interaction
- Tests for all room transitions

### Example 3: Tic-Tac-Toe
**Prompt:** "Create a tic-tac-toe game for two players"

**Expected Output:**
- Game board representation
- Move validation
- Win detection
- Tests for all win conditions

## Key Principles

### Keep It Simple
- Start with text-based games
- No complex graphics or animations
- Focus on core loop working first
- Iterate on complexity later

### Use Existing Infrastructure
- Leverage `ArxivSummarizer` for Gemini calls
- Reuse `PaperChatSession` for debugging
- Use existing config and error handling patterns
- Follow direct & minimal style guide

### Safety First
- Sandboxed code execution
- Timeout and memory limits
- No file system or network access
- Validation of generated code before execution

### Iterative Refinement
- Start with basic code generation
- Add testing once generation works
- Add debugging once testing works
- Add polish once everything works

## Technical Requirements

### Dependencies (Existing)
- `google-genai` - Gemini API (already installed)
- `pydantic` - Structured output (already installed)
- `pytest` - Testing framework (already installed for tests)

### New Dependencies (Minimal)
- None initially - use stdlib only
- May add `importlib.util` for dynamic imports
- May add `tempfile` for temp code files

### File Structure
```
arxiv_paper_pulse/
  self_playing_game.py    # Main module
  data/
    self_generated_games/  # Output directory
      game_001_<timestamp>/
        game.py
        test_game.py
        README.md
        results.json
```

## Next Steps

1. **Start Simple**: Create Phase 1 - basic code generation and execution
2. **Test First Game**: Generate a simple guessing game and verify it works
3. **Add Testing**: Once generation works, add test generation
4. **Add Debugging**: Once testing works, add error recovery
5. **Polish**: Once everything works, add documentation

## Notes
- Following direct & minimal Python style guide
- Reuse existing Gemini API infrastructure
- Keep games simple and text-based initially
- Focus on getting the core loop working before adding features
- Use existing patterns from `core.py`, `chat.py`, `documents.py`

